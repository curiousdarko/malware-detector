# NOTE
# ONLY WORKS WITH DLLS LISTED BELOW. IF IT IS A KERNEL DRIVER FOR CHEATS, RENAME THE CHEATS TO "kernel32.dll" AND USE THAT
# IF YOU DON'T KNOW WHICH CATEGORY IT FITS INTO, EITHER ASK ME (center#6937) OR TRY AND USE YOUR BRAIN.
# files supported: .exe, .jar, .dll and .vbs

import os
import sys
import logging
import pefile
import zipfile

# Define the DLL compatibility dictionary
DLL_COMPATIBILITY = {
    'kernel32.dll': ['VirtualAlloc', 'VirtualFree', 'VirtualProtect', 'VirtualQuery', 'CreateFile', 'ReadFile', 'WriteFile', 'CloseHandle'],
    'advapi32.dll': ['RegOpenKeyExA', 'RegQueryValueExA', 'RegSetValueExA', 'RegCloseKey'],
    'user32.dll': ['MessageBoxA'],
    'gdi32.dll': ['CreateCompatibleDC', 'CreateCompatibleBitmap', 'CreateFontIndirectA', 'SelectObject', 'BitBlt', 'DeleteDC', 'DeleteObject'],
    'ole32.dll': ['CoInitializeEx', 'CoCreateInstance', 'CoUninitialize'],
    'shell32.dll': ['ShellExecuteA'],
    'wininet.dll': ['InternetOpenA', 'InternetOpenUrlA', 'InternetReadFile', 'InternetCloseHandle'],
    'ws2_32.dll': ['WSAStartup', 'socket', 'connect', 'send', 'recv', 'closesocket', 'WSACleanup']
}

def log_activity(message):
    logging.basicConfig(filename='activity.log', level=logging.INFO)
    logging.info(message)

def log_result(message):
    logging.basicConfig(filename='results.log', level=logging.INFO)
    logging.info(message)

def detect_malicious(file_path):
    # Check if file exists
    if not os.path.exists(file_path):
        log_result(f"File {os.path.basename(file_path)} not found")
        return False

    # Check if the file is a Windows executable, a JAR file, or a VBS file
    if file_path.lower().endswith('.jar'):
        try:
            with zipfile.ZipFile(file_path, 'r') as zip_file:
                for name in zip_file.namelist():
                    if name.endswith('.class'):
                        log_activity(f"File {os.path.basename(file_path)} contains a class file {name}")
                        break
        except zipfile.BadZipFile:
            log_result(f"File {os.path.basename(file_path)} is not a valid JAR file")
            return False
    elif file_path.lower().endswith('.vbs'):
        log_activity(f"File {os.path.basename(file_path)} is a VBS file")
    else:
        try:
            pe = pefile.PE(file_path)
        except pefile.PEFormatError:
            log_result(f"File {os.path.basename(file_path)} is not a valid Windows executable")
            return False

        # Check if the file is compatible with known DLLs
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode().lower()
            if dll_name in DLL_COMPATIBILITY:
                for function in entry.imports:
                    func_name = function.name.decode().lower()
                    if func_name in DLL_COMPATIBILITY[dll_name]:
                        log_activity(f"Program {os.path.basename(file_path)} is compatible with {dll_name}.{func_name}")
            else:
                log_activity(f"Program {os.path.basename(file_path)} is not compatible with {dll_name}")

        # Check if the file tries to modify memory
        for section in pe.sections:
            if section.IMAGE_SCN_MEM_WRITE:
                log_activity(f"Program {os.path.basename(file_path)} tries to modify memory in {section.Name.decode().rstrip('\x00')}")

    return True

if __name__ == '__main__':
    if len(sys.argv) == 1:
        print("Usage: python detect_malicious.py <file_path>")
        sys.exit(1)

    file_path = sys.argv[1]

    if not os.path.isfile(file_path):
        print(f"Error: {file_path} is not a valid file path")
        sys.exit(1)

    detect_malicious(file_path)
