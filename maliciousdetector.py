# NOTE
# ONLY WORKS WITH DLLS LISTED BELOW. IF IT IS A KERNEL DRIVER FOR CHEATS, RENAME THE CHEATS TO "kernel32.dll" AND USE THAT
# IF YOU DON'T KNOW WHICH CATEGORY IT FITS INTO, EITHER ASK ME (center#6937) OR TRY AND USE YOUR BRAIN.

import os
import sys
import logging
import pefile

# Define the DLL compatibility dictionary
DLL_COMPATIBILITY = {
    'kernel32.dll': ['VirtualAlloc', 'VirtualFree', 'VirtualProtect', 'VirtualQuery', 'CreateFile', 'ReadFile', 'WriteFile', 'CloseHandle'],
    'advapi32.dll': ['RegOpenKeyExA', 'RegQueryValueExA', 'RegSetValueExA', 'RegCloseKey'],
    'user32.dll': ['MessageBoxA'],
    'gdi32.dll': ['CreateCompatibleDC', 'CreateCompatibleBitmap', 'CreateFontIndirectA', 'SelectObject', 'BitBlt', 'DeleteDC', 'DeleteObject'],
    'ole32.dll': ['CoInitializeEx', 'CoCreateInstance', 'CoUninitialize'],
    'shell32.dll': ['ShellExecuteA'],
    'wininet.dll': ['InternetOpenA', 'InternetOpenUrlA', 'InternetReadFile', 'InternetCloseHandle'],
    'ws2_32.dll': ['WSAStartup', 'socket', 'connect', 'send', 'recv', 'closesocket', 'WSACleanup']
}

def log_activity(message):
    logging.basicConfig(filename='activity.log', level=logging.INFO)
    logging.info(message)

def detect_malicious(file_path):
    # Check if file exists
    if not os.path.exists(file_path):
        return False

    # Check if the file is a Windows executable
    try:
        pe = pefile.PE(file_path)
    except pefile.PEFormatError:
        return False

    # Check if the file is compatible with known DLLs
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        dll_name = entry.dll.decode().lower()
        if dll_name in DLL_COMPATIBILITY:
            for function in entry.imports:
                func_name = function.name.decode().lower()
                if func_name in DLL_COMPATIBILITY[dll_name]:
                    log_activity(f"Program {os.path.basename(file_path)} is compatible with {dll_name}.{func_name}")
        else:
            log_activity(f"Program {os.path.basename(file_path)} is not compatible with {dll_name}")

    # Check if the file tries to modify memory
    for section in pe.sections:
        if section.IMAGE_SCN_MEM_WRITE:
            log_activity(f"Program {os.path.basename(file_path)} tried to modify memory")

    # Check if the file tries to tamper with files
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        if 'kernel32.dll' in str(entry.dll):
            for function in entry.imports:
                if 'WriteFile' in str(function.name):
                    log_activity(f"Program {os.path.basename(file_path)} tried to tamper with files")

    # Check if the file communicates with an external server
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        if 'ws2_32.dll' in str(entry.dll):
            for function in entry.imports:
                if 'connect' in str(function.name):
                    log_activity(f"Program {os.path.basename(file_path)} sent a request to {function.name}")

    # Check if the file tries to modify the registry
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        if 'advapi32.dll' in str(entry.dll):
            for function in entry.imports:
                if 'RegOpenKeyExA' in str(function.name):
                    log_activity(f"Program {os.path.basename(file_path)} tried to modify the registry {function.name}")

    return True

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python detect_malicious.py <file_path>")
        sys.exit(1)

    file_path = sys.argv[1]
    detect_malicious(file_path)
